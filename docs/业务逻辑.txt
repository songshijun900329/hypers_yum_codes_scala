业务逻辑：

### 业务逻辑:

1. 消费Kafka中的标签数据，对每条数据进行处理:
2. 【查询人群规则列表】查询人群Hbase中，全表查，查出的list中，筛选matchInfo.orderTime在startTime和endTime之间的人群列表，为激活状态的人群
3. 【去重已发数据】对于每条人群结果，拼接MD5(userCode)+crowdCode,去人群结果Hbase表中，查询是否已经存在人群结果，对于已经存在人群结果的人群，从人群列表中去除该人群，生成去重后的人群列表（防止对于下游的重复推送）
4. 【查询标签结果列表】按照rowkey前缀MD5(userCode), 查询Hbase中的该用户的所有标签结果
5. 【过滤标签结果列表】对于每3.中的每个人群结果，对标签结果列表，进行预过滤：选取标签orderTime在人群startTime和endTime之间的标签，生成过滤后的标签结果列表
6. 【规则判断】将6.中的的标签列表，进行与或关系的处理，生成人群结果（第一期可以只做最外层的与逻辑关系）
7. 【结果推送】将人群结果列表，推送到Kafka和Hbase中


### 

PS：
【步骤二】：
先检索出人群规则表（swift:dim_crowd_src）的所有数据，
遍历list，
list里的起止时间（startTime、endTime）
能覆盖kafka标签结果数据的订单时间（orderTime）的留下，不能覆盖的滤掉











